# Lectures 17–18: Quality of Service (QoS)

---

## 1. Why QoS?

Applications require predictable performance defined by:

- **Bandwidth (BW)** – data per second  
- **Delay** – transmission latency  
- **Loss** – dropped packets  
- **Jitter** – variation in delay  

Real applications (VoIP, gaming, video conferencing) are highly sensitive to these metrics.  
Basic FIFO routers cannot provide such guarantees -> **QoS mechanisms** are needed.

---

## 2. Delay, Jitter, and Playout Buffers

### Delay & Jitter
- **Jitter** = variance of packet delay.
- Caused by queueing, congestion, variable routing.

### Playout Buffer
Used in audio/video streaming to absorb jitter:

- Buffers packets before playback.  
- **Low delay** = responsive but risk of gaps.  
- **High delay** = smooth playback but more latency.  
- Adjusted using **high/low watermarks** (dynamic thresholds adjusted based on BW, delay, loss).  

**Intuition example:** YouTube’s gray buffered bar.

---

## 3. Traffic Shaping: Token Bucket

**Goal:** Control burstiness and enforce traffic contracts.

### Token Bucket Model
- Tokens added at rate **R** (bytes/sec).  
- Bucket capacity **B** tokens (max burst).  
- Sending x bytes requires x tokens.  
- If bucket empty → sender must wait.

**Uses:**
- Avoid burst-induced congestion.  
- Regulate flows to match network capacity.  
- Enforce ISP / enterprise policy.

---

## 4. Fairness

### Why Fairness?
- Prevent starvation  
- Share bottleneck resources reasonably  
- Maintain service quality for multiple flows

---

### Max–Min Fairness

A rate allocation is **max–min fair** if increasing any flow requires decreasing another flow with **equal or smaller** rate.

**Water-Filling Process:**
1. Start all flows at 0.
2. Increase all evenly.
3. Stop increasing flows whose path hits a bottleneck.
4. Continue increasing others.

---

## 5. Queueing & Scheduling

Different scheduling policies determine how packets are transmitted.

---

### FIFO (Drop Tail)

- First-in-first-out  
- Drops packets when full  
- Susceptible to unfairness — aggressive flows dominate

---

### Round Robin (RR)

- One queue per flow  
- Each queue gets turns  
- **Problem:** unfair for different packet sizes (large packets get more bandwidth)

---

### Fair Queuing (FQ)

Simulates bit-by-bit round robin:
  - Finish(j) = max(Arrive(j), Finish(j-1)) + Length(j)

- Packets served in order of increasing finish times  
- Approximates fair bandwidth distribution  
- Prevents one flow from hogging link capacity

---

### Weighted Fair Queuing (WFQ)

Generalizes FQ:
  - Finish(j) = max(Arrive(j), Finish(j-1)) + Length(j)/Weight

- Higher weight → more bandwidth  
- Used for **rate guarantees**  
- Issues:
  - Must maintain per-flow queues  
  - Hard to implement at high speed  
  - Requires classification (what is a “flow”?)

---

## 6. Differentiated Services (DiffServ)

A scalable approach used by ISPs, large networks.

### Core Ideas
1. **Mark packets** at network edges using DSCP (6-bit field).  
2. **Police** traffic based on service contract.  
3. **Treat classes differently** inside the network using priority / WFQ.

---

### DSCP Classes (Examples)

| Class | DSCP | Typical Use |
|-------|-------|-------------|
| Default (Best Effort) | 0 | Bulk transfer |
| Assured Forwarding | 10–38 | Streaming |
| Expedited Forwarding | 46 | VoIP, gaming |
| Network Control | 48 | Routing protocols |

### Characteristics
- Works on **aggregated classes**, not flows -> scalable  
- No strict end-to-end guarantees  
- Routers only enforce *per-hop behaviors*

---

## 7. Integrated Services (IntServ)

Provides **hard QoS guarantees** for each flow.

### Components
- **Token bucket** flow specification (R, B)  
- **Admission control:** routers decide if they can support a new flow  
- **RSVP:** signaling protocol to install per-flow state  
- **WFQ:** enforces rate & delay guarantees  

---

## 8. End-to-End QoS Spectrum

QoS mechanisms range from simple to strong:
```txt
Best Effort → RED → WFQ → DiffServ → IntServ
```

- More complex -> stronger guarantees  
- Real networks often combine layers (e.g., DiffServ at core, token buckets at edge)

---

## Takeaways

- QoS optimizes network performance for delay-, jitter-, loss-, and bandwidth-sensitive apps.  
- Playout buffers + jitter estimation enable smooth media playback.  
- Token bucket shaping prevents burst-induced congestion.  
- Fairness (Max–Min, Jain’s index) ensures equitable distribution of bandwidth.  
- Scheduling algorithms (RR, FQ, WFQ) determine how packets compete at bottleneck links.  
- DiffServ offers scalable, class-based QoS via DSCP and WFQ.  
- IntServ uses RSVP + WFQ to provide **true per-flow guarantees** of rate and delay.
